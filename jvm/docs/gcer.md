本文摘自书籍[《深入理解Java虚拟机：JVM高级特性与最佳实践》](https://www.amazon.cn/dp/B00DA0E170/ref=sr_1_1_twi_kin_2?s=books&ie=UTF8&qid=1528283344&sr=1-1&keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA) 

## 垃圾收集器

如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。

### Serial 收集器

新生代垃圾收集器，是最基本的收集器，是一个单线程的收集器且当它进行垃圾收集时，且必须暂停其它所有的工作线程，直到它收集结束。在用户不可见的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是难以接受的。

#### 是否暂停用户线程

是

#### 采用算法

复制收集算法

#### 适用环境

Client 模式下的虚拟机

### Serial Old 收集器

老年代垃圾收集器，与Serial 收集器一样，是一个单线程收集器。

#### 是否暂停用户线程

是

#### 采用算法

标记 - 整理算法

#### 适用环境

Client 模式下的虚拟机

### ParNew 收集器

新生代垃圾收集器，是Serial 收集器的多线程版本，除了为多线程以外，其余与Serial 收集器完全相同。ParNew 收集器在单CPU 环境中绝对不会比Serial 收集器效果好。

#### 是否暂停用户线程

是

#### 采用算法

复制收集算法

#### 适用环境

Server 模式下的虚拟机

### Parallel Scavenge 收集器

新生代垃圾收集器，是并行的多线程收集器。目标是达到一个可控制的吞吐量，高效利用CPU 时间，尽快完成程序的运算任务。

#### 吞吐量

CPU 用于运行代码的时间与CPU 总消耗时间的比值。

```java
吞吐量 = 运行代码时间 / (运行用户代码时间 + 垃圾收集时间)
```

#### 是否暂停用户线程

是

#### 采用算法

复制收集算法

#### 适用环境

运算而不需要太多交互

#### 控制参数

1）控制吞吐量

控制最大垃圾收集停顿时间，接受大于0的毫秒数，收集器将尽量保证内存回收花费的时间不超过设定值，GC停顿时间缩小是以牺牲吞吐量和新生代空间来换取的 - 系统会将新生代空间调小，这会导致垃圾收集更加频繁：

```java
-XX:MaxGCPauseMillis
```

吞吐量大小，接受大于0小于100的整数，也就是垃圾收集时间占总时间的比率，最大垃圾收集时间 = 1 / (1 + 设置的值)：

```java
-XX:GCTimeRatio
```

2）自适应调节策略

```java
-XX:+UseAdaptiveSizePolicy
```

设置此参数后，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数（新生代大小、Eden与Survivor区的比例、晋升老年代对象年龄等）以提供最合适的停顿时间或最大的吞吐量。

### Parallel Old 收集器

老年代垃圾收集器，是Parallel Scavenge 收集器的老年代版本。

#### 是否暂停用户线程

是

#### 采用算法

标记 - 整理算法

#### 适用环境

运算而不需要太多交互

### CMS 收集器

老年代垃圾收集器，是一种以获取最短回收停顿时间为目标的收集器。

#### 过程

1）初始标记

标记GC Roots能直接关联到的对象，速度很快。

2）并发标记

进行 GC Roots Tracing 过程。

3）重新标记

修正并发标记期间，因用户程序继续运作而导致标记产生变化的一部分对象的标记记录。

4）并发清除

清除被判定为死亡的对象。

由于整个过程中最耗时的并发标记与并发清除过程中与用户线程一起工作，所以可以认为GMS 收集器的内存回收过程是与用户线程一起并发执行的。

#### 是否暂停用户线程

是，暂停包含过程：初始标记、重新标记

#### 采用算法

标记 - 清除算法

#### 缺点

1）对CPU 资源非常敏感，在并发阶段，占用一部分线程（CPU 资源）而导致应用程序变慢，吞吐量降低。CMS 默认启动的回收线程数为：(CPU 数量 + 3) /4。

2）无法处理浮动垃圾，可能出现`Concurrent Mode Failure`失败而导致另一次`	Full GC`的产生。由于CMS 在进行并发清理阶段用户线程还在运行，伴随程序运行而产生垃圾，这一部分垃圾出现在标记过程之后，CMS 无法在本次收集中处理掉他们，只好等待下一次GC时处理，这一部分垃圾被称为浮动垃圾。由于进行清理时，同时需要维持用户线程使用内存，所以需要预留一部分空间供并发收集时的用户程序运作，而这一部分占用的内存空间导致老年代内存空间不能被完全填满时再进行收集。默认情况下，CMS 收集器老年代内存使用达到68%时，触发垃圾回收。可以通过参数来控制触发百分比：

```java
-XX:CMSInitiatingOccupancyFractioon
```

当CMS 运行期间预留的用户内存无法满足程序的需要时，就会出现`Concurrent Mode Failure`，这时候虚拟机会临时启动Serial Old收集器来重新进行老年代的`GC`，会导致停顿时间长。

3）标记 - 清除算法将在清理后产生大量的空间碎片，为了解决此问题，CMS 提供了一个参数控制是否在`GC`后进行一次碎片整理，在整理期间，无法并发：

```java
-XX:UseCMSCompactAtFullCollection
```

但是通过此参数虽然解决了问题，但是将造成停顿时间大大增加，为了解决这个问题，附加了一个参数来控制多少次GC 后才执行一次整理：

```java
-XX:CMSFullGCsBeforeCompaction
```

### G1 收集器

相比于CMS 收集器，有两个显著的改进：

1）G1 收集器是基于 标记 - 整理算法实现的。

2）可以非常精确的控制停顿，技能让使用者明确指定在一个长度为M 毫秒的时间片段内，消耗在垃圾手机上的时间不得超过N 毫秒。

可以实现在基本不牺牲吞吐量的前提下完成低停顿对的内存回收，这是由于它能够极力地避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或老年代，而G1 将Java 堆划分为了多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积成都，在后台维护一个优先列表，每次根据允许的收集时间，优先收集垃圾多的区域。

### 收集器参数汇总

| 参数                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                    | 虚拟机运行在Client模式下的默认值，设置参数将使用 Serial + Serial Old 收集器组合进行GC |
| UseParNewGC                    | 使用ParNew + Serial Old 收集器组合进行GC                     |
| UseConcMarkSweepGC             | 使用 ParNew + CMS + Serial Old 收集器组合进行GC。当出现`Concurrent Mode Failure`时，临时启动 Serial Old 进行GC |
| UseParallelGC                  | 虚拟机运行在Server模式下的默认值，使用Parallel Scavenge + Serial Old 收集器组合进行GC |
| UseParallelOldGC               | 使用Parallel Scavenge + Parallel Old 收集器组合进行GC        |
| SurvivorRatio                  | 新生代Eden 区与Survivor区的容量比值，默认为 8                |
| MaxTenuringThreshold           | 晋升到老年代的对象年龄，每个对象在坚持过一次Minior GC 后年龄 +1 |
| UseAdaptiveSizePolicy          | 动态调整Java 堆中各个区域的大小及进入老年代的年龄            |
| PretenureSizeThreshold         | 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 |
| HandlePromotionFailure         | 是否允许分配担保失败，即来年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 |
| GCTimeRatio                    | GC 时间占总时间的比率，默认值为99，即1%的GC 时间，仅在使用 Parallel Scavenge 收集器时有效 |
| ParallelGCThreads              | 设置并行 GC 时进行内存回收的线程数                           |
| MaxGCPauseMillis               | 设置 GC 的最大停顿时间，仅在使用 Parallel Scavenge 收集器时有效 |
| CMSInitiatingOccupancyFraction | 设置CMS 收集器在老年代空间被使用多少时触发 GC，默认68%       |
| UseCMSCompactAtFullCollection  | 设置CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理     |
| CMSFullGCsBeforeCompaction     | 设置CMS 收集器在进行若干次GC 后再启动一次碎片中整理          |

