本文摘自书籍[《深入理解Java虚拟机：JVM高级特性与最佳实践》](https://www.amazon.cn/dp/B00DA0E170/ref=sr_1_1_twi_kin_2?s=books&ie=UTF8&qid=1528283344&sr=1-1&keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA) 

## 内存分配与回收策略

Java 自动化的解决了两个问题：给对象分配内存、回收分配给对象的内存。对象的内存分配，从大方向来说就是堆上的分配，对象主要分配在新生代的Eden 区上，若启动了TLAB，将按线程优先在TLAB 上分配。少数情况下也可能直接分配在老年代中。

#### Minor GC

新生代GC，指发生在新生代的GC 动作。

#### Full GC / Major GC

老年代GC，指发生在老年代的GC 动作，Full GC的速度一般比Minor GC 慢十倍以上。

#### TLAB

本地线程分配缓冲，JVM在内存新生代中开辟了一小块线程私有的区域，称作TLAB。默认占新生代的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享，同时适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。 也就是说，Java中每个线程都会有自己的缓冲区称作TLAB（Thread-local allocation buffer），每个TLAB都只有一个线程可以操作，TLAB结合bump-the-pointer技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。 

### 对象优先在Eden 分配

大多数情况下，对象在新生代的Eden 区分配，当Eden 区没有足够的空间时，进行一次Minior GC。虚拟机提供了参数`-XX:+PrintGCDetails`告诉虚拟机在发生GC 时打印内存回收日志，并且在进程退出时输出当前内存各区域的分配情况。在IDE中也可以配置JVM 参数来执行程序，可以通过IDE 来打印日志以便更好的观察。

### 大对象直接进入老年代

大对象指需要大量连续内存空间的对象，最典型的大对象就是很长的字符串及数组。大对象对虚拟机的内存呢分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时提前触发GC 以获取足够的连续空间。虚拟机提供了参数`-XX:PretenureSizeThreshold`参数，使得大于值的对象直接在老年代分配，避免Eden 区及Survivor区之间发生大量的内存拷贝。

### 长期存活对象进入老年代

若对象在Eden 区出生并经过第一次Minor GC 后存活，并且能被Survivor 容纳，此时将对象的年龄设为1。对象在Survivor区每存活过一次Minor GC，年龄+1，当年龄达到一定岁数（默认15岁）时，就会被晋升到老年代中，可以通过参数控制这个年龄阀值：`-XX:MaxTenuringThreshold`。

### 动态对象年龄判定

为了能更好的使用不同程序的内存状况，虚拟机你并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor 空间中相同年龄所有对象大小的综合大于Survivor空间的一般，年龄大于或等于该年龄的对象就可直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

### 空间分配担保

在发生Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果先于，则查看HandlePromotionFailure 设置是否允许担保失败，若允许，那只会进行Minor GC，若不允许，则改为进行一次Full GC。

新生代使用复制算法，为了内存利用率，只使用其中一个Survivor 空间来作为轮换备份，因此当出现大量对象在Minor GC 后任然存活的情况时，就需要老年代进行分配担保，让Survivor 无法容纳的对象直接进入老年代。老年代进行担保的前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代提供更多的空间。