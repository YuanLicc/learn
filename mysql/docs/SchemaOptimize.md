## Schema 与数据类型优化

### 选择优化的数据类型

1）更小的通常更好：

一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为他们占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期更少。但是要确保没有低估存储的值的范围，因为在 schema 中的多个地方增加数据类型的范围是一个非常好事和痛苦的操作。如果午饭确定那个数据类型是最好的，就选择你认为不会超过范围的最小类型。

2）简单就好：

简单的数据类型的操作通常需要更少的 CPU 周期。例如，整型比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比整型更加复杂。两个例子：一个是应该使用 MYSQL 内建的类型而不是字符串来存储日期和时间，另一个是应该用整型存储 IP 地址。

3）尽量避免 NULL

很多表都包含可为 NULL 的列，即使应用程序并不需要保存 NULL 也是如此，这是因为可为 NULL 是列的默认属性。通常情况下最好指定列为 NOT NULL，除非真的需要存储 NULL 值。如果查询中包含可为 NULL 的列，对 MySQL 来说更难优化，因为可为 null 的列使得索引、索引统计和值比较都更复杂。可为 null 的列会使用更多的存储空间，在 MySQL 中也需要特殊处理。当可为 Null 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 中甚至还可能导致固定大小的索引变成可变大小的索引。通常把可为 null 的列改为 not null 带来的性能提升比较小，所以没有必要首先在现有的 schema 中查找并修改掉这种情况，除非确定这会导致问题，但是，如果计划在列上建立索引，就应该避免设计成可为 null 的列。

在为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等。下一步是选择具体类型。很多 MySQL 的数据类型可以存储相同类型的户数，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间不同。相同的大类型的不同子类型数据有时也有一些特殊的行为和属性。例如：DATETIME 和 TIMESAMP 列都可以存储相同类型的户数：时间和日期，精确到秒。然而 TIMESAMP 只使用 DATETIME 一半的存储空间，并且会根据时区辩护哈，具有特殊的自动更新能力。另一方面，TIMESAMP 允许的时间范围要小得多，有时候它的特殊能力会成为障碍。

#### 整型类型

两种类型的数字：整数和实数。若存储整数，可以使用这几种整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。分别使用 8、16、24、32、64 位存储空间。

整数类型有可选的 UNSIGNED 属性，表示不允许负值，这大致可以使正数的上线提高一倍。例如 TINYINT UNSIGNED 可以存储的范围是 0 - 255，而 TINYINT 的存储范围是 -128 -- 127。

有符号和无符号类型使用相同的存储空间，并且具有相同的性能，因此可以根据实际情况选择合适的类型。

MySQL 可以为整数类型指定宽度，例如 INT(11)，对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了 MySQL 的一些交互工具用来显示字符的个数。对于存储和计算涞水，INT(1) 和 INT(20) 是相同的。

#### 实数类型

实数是带有小数部分的数字。然而，他们不只是为了存储小数部分，也可以使用 DECIMAL 存储比 BIGINT 还大的整数。MySQL 既支持精确类型也支持不精确类型。FLOAT 和 DOUBLE 类型支持使用标准的浮点运算进行近似计算。如果要知道浮点运算是怎么计算的，则需要研究所使用的平台的浮点数的具体实现。DECIMAL 类型用于存储精确的小数，支持精切计算。

因为 CPU 不支持对 DECIMAL 的直接计算，所以 MySQL 服务器自身实现了 DECIMAL 的高精度计算。相对而言，CPU 直接支持原生浮点计算，所以浮点运算明显更快。

浮点和 DECIMAL 类型都可以指定精度。对于 DECIMAL 列，可以指定小数点前后允许的最大位数。这会影响列的空间消耗。MySQL 5 及以上将数字打包保存到一个二进制字符串中。MySQL 5 及以上版本中的 DECIMAL 类型允许最多 65 个数字。而早期的 MySQL 版本中这个限制时 254 个数字，并且保存为未压缩的字符串。

有多重方法可以指定浮点列所需要的精度，这会使得 MySQL 悄悄选择不同的数据类型，或者在存储时对值进行取舍。这些精度定义是非标准的，所以我们建议只指定数据类型，不指定精度。

浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。FLOAT 使用 4 个字节存储。DOUBLE 占用 8 个字节，相比 FLOAT 有更高的精度和更大的范围。和整数类型一样，能选择的知识存储类型。MySQL 使用 Double 作为内部浮点计算的类型。

因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用 DECIMAL，如财务。在数据量比较大的时候，可以考虑使用 BIGINT 代替 DECIMAL。将需要存储的货币单位根据小数的位数乘以相应的倍数即可。假设要存储财务数据精确到万分之一，则可以把所有金额乘以一百万，然后将结果存储在 BIGINT 中，这样可以同时避免浮点存储计算不精确和 DECIMAL 精确计算代价高的问题。

#### 字符串类型

MySQL 支持多种字符串类型，每种类型还有很多变种。VARCHAR 和 CHAR 是两种最主要的字符串类型。不幸的是，很难精确的解释这些值是怎么存储在磁盘和内存中的，因为这根存储引擎的具体实现有关。存储引擎 CHAR 或者 VARCHAR 值的方式在内存中和在磁盘中可能不一样，所以 MySQL 服务器从存储引擎读出的值可能需要转换为另一种存储格式。



1、VARCHAR

VARCHAR 类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅适用必要的空间，如越短的字符串适用越少的空间。例外：如果 MySQL 表使用 ROW_FORMAT=FIXED 创建的话，每一行都会使用定长存储，这回很浪费空间。VARCHAR 需要使用 1或 2 个额外字节记录字符串的长度：如果列的最大长度小于或等于 255 字节，则只使用 1 个字节表示，否则使用 2 个字节。VARCHAR 节省了存储空间，所以堆性能也有帮助。但是，由于行是变长的，在 UPDATE 时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的存储空间增长，并且在页内没有更多的空间可以存储，在这种情况下，不同的存储引擎的处理方式是不一样的。如 MyISAM 会将行拆成不同的片段存储，InnoDB 则需要分裂页来使行可以放进页内。什么时候使用 VARCHAR：

1）字符串列的最大长度比平均长度大得多。

2）列的更新很少，所以碎片不是问题。

3）使用了 UTF-8 这种复杂字符集，每个字符都使用不同的字节数来存储。



2、CHAR

CHAR 类型是定长的：MySQL 总是根据定义的字符串长度分配足够的空间。当存储 CHAR 值时，MySQL 会删除所有的末尾空格。CHAR 值会根据需要采用空格进行填充以方便比较。CHAR 适合存储很短的字符胡灿，或者所有值都接近同一个长度，例如，CHAR 非常适合存储密码的 MD5 值，因为这是一个定长的值。对于经常变更的数据，CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片。对于非常短的列，CHAR 比 VARCHAR 在存储空间上也更有效率。因为 VARCHAR 会多一个或两个字节来记录长度。

数据如何存储取决于存储引擎，并非所有的存储引擎都会按照相同的方式处理定长和变长的字符串。Memory 引擎只支持定长的行，即使有变长字段也会根据最大长度分配最大空间。不过，填充和截取空格的行为在不同存储引擎都是一样的，因为这是 MySQL 服务器层进行处理的。

与 CHAR 和 VARCHAR 类似的类型还有 BINARY 和 VARBINARY，他们存储的是二进制字符串，二进制字符串跟常规字符串非常相似，但是二进制字符串存储的是字节码而不是字符。填充也不一样：MySQL 填充 BINARY 采用的是零字节而不是空格，在检索时也不会去掉填充值。当需要存储二进制数据，并且希望 MySQL 使用字节码而不是字符进行比较时，这些类型是非常有用的。二进制比较的优势并不仅仅体现在大小写敏感上。MySQL 比较 BINARY 字符串时，每次按一个字节，并且根据该字节的数值进行比较，因此，二进制比较比字符串比较简单得多，所以更快。

事实证明，使用更短的列有很大的优势。更长的列会消耗更多的内存，因为 MySQL 通常会分配固定大小的内存块来保护内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。再利用磁盘临时表进行排序时也同样糟糕。所以最好的策略是只分配真正想要的空间。



3、BLOB 和 TEXT 类型

BLOB 和 TEXT 都是存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。实际上他们分别属于两组不同的数据类型家族：字符类型是 TINYTEXT、SMALLTEXT、TEXT、MEDIUMTEXT、LONGTEXT；对应的二进制类型是 TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。BLOB 是 SMALLBLOB 的同义词，TEXT 是 SMALLTEXT 的同义词。

与其他类型不同，MySQL 把每个 BLOB 和 TEXT 值当做一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当 BLOB 和 TEXT 值太大时，InnoDB 会使用 专门的“外部” 存储区域来进行存储，此时每个值在行内需要 1-4 个字节存储一个指针，然后在外部存储区域存储实际的值。

BLOB 和 TEXT 家族之间仅有的不同时 BLOB 类型存储的是二进制数据，没有排序规则会字符集，而 TEXT 类型有字符集和排序规则。MySQL 对 BLOB 和 TEXT 列进行排序与其它类型是不同的：它只对每个列的最前 max_sort_length 字节而不是整个字符串做排序。如果只需要排序前面一小部分字符，则可以减小 max_sort_length 的配置，或者使用 ORDER BY SUSTRING(column, length)。MySQL 不能将 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。



磁盘临时表和文件排序：

因为 Memory 引擎不支持 BLOB 和 TEXT 类型，所以，如果查询使用了 BLOB 或 TEXT 列并且需要使用隐式临时表，将不得不使用 MyISAM 磁盘临时表，即使只有几行数据也是如此。这回导致严重的性能开销。即使配置 MySQL 将临时表存储在存储块设备上，依然需要许多昂贵的系统调用。

最好的解决防范是尽量避免使用 BLOB 和 TEXT 类型。如果实在无法避免，有一个技巧是在所有用到 BLOB 字段的地方都使用 SUBSTRING(column, length) 将列值转换为字符串，这样使临时表的大小超过 max_heap_table_size 或 tmp_table_size，超过以后 MySQL 会将内存临时表转换为 MyISAM 磁盘临时表。

最坏情况下的长度分配对于排序的时候也是一样的，所以这一招对于内存中创建大临时表和文件排序，以及在磁盘上创建打临时表和文件排序这两种情况都很有帮助。



4、ENUM

有事就可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符胡灿存储成一个预定义的集合。MySQL 在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL 在内部会将每个值在列表中的位置保存为证书，并且在表的 .frm  文件中保存 “数字 - 字符串” 映射关系的查找表。例子：

```mysql
create table enum_table(
	e ENUM ('a', 'b', 'c') not null
);

insert into enu_table(e) values('a'),('c'),('b');
```

这三行数据实际被存储为整数，而不是字符串：

```mysql
select e + 0 as e from enum_table;
```

结果：

```mysql
1
3
2
```

另外，枚举字段是按照内部存储的整数而不是定义的字符胡灿进行排序的，一种绕过这种限制的方式是按照需要的顺序来定义枚举列。另外也可以在查询中使用 FIELD() 函数显示的指定排序顺序，但这会导致 MySQL 无法利用索引消除排序。

```mysql
select e from enum_table order by FIELD(e, 'b','a','c');
```

枚举最不好的地方是，字符串列表式固定的，添加或删除字符串必须使用 ALTER TABLE。因此，对于一些列未来可能会改变的字符串，使用枚举不是一个好主意，除非能接受只在列表末尾添加元素。由于 MySQL 把每个枚举值保存为整数，并且必须进行查找才能转换为字符串，所以枚举有一些开销。通常枚举的列表都比较小，所以开销还可以控制，但也不能保证一直如此。在特定情况下，把 CHAR/VACHAR 列与枚举列进行关联可能会比直接关联 CHAR/VARCHAR 列更慢。



#### 日期和时间类型

MySQL 可以使用许多类型来保存日期和时间值，例如 YEAR 和 DATE。MySQL 能存储的最小时间粒度为妙。但是 MySQL 也可以使用微妙级的粒度进行临时运算。大部分时间类型都没有替代品，因此没有什么是最佳选择的问题。唯一的问题是保存日期和时间的时候需要做什么。MySQL 提供两种相似日期类型：DATETIME 和 TIMESTAMP。对于很多应用程序，他们都能工作，但是在某些场景，一个比另一个工作得好。



1）DATETIME

这个类型能保存大范围的值，从 1001 年到 9999 年，精度为妙。它把日期和时间封装到格式为 YYYYMMDDHHMMSS的证书中，与失去无关。使用 8 个字节的存储空间。默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值。



2）TIMESTAMP

它和 UNIX 时间戳相同。TIMESTAMP 只使用 4 个字节的存储空间，因此它的范围比 DATETIME 小得多：只能表示从 1970 年到 2038 年。MySQL 提供了 FROM_UNIXTIME() 函数把 Unix 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 Unix 时间戳。TIMESTAMP 显示的值也依赖于时区。MySQL 服务器、操作系统，以及客户端连接都有时区设置。TIMESTAMP 显示的值也依赖于时区。MySQL 服务器、操作系统以及客户端连接都有时区设置。因此存储值为 0 的 TIMESTAMP 在美国东部显示为 “1969-12-31 19:00:00”，与格林尼治时间差5个小时。有必要强调一下这个区别：如果在多个时区存储或访问数据，TIMESTAMP 和 DATETIME 的行为将很不一样。前者提供的值与时区有关系，后者保留文本表示的日期和时间。

TIMESTAMP 也有 DATETIME 没有的特殊属性。默认情况下，如果插入时没有指定第一个 TIMESTAMP 列的值，MySQL 则设置这个列的值为当前时间。在插入一行记录时，MySQL 默认也会更新第一个 TIMESTAMP 列的值。你可以配置任何 TIMESTAMP 列的插入和更新行为。最后，TIMESTAMP 列默认为 NOT NULL，这也和其它的数据类型不一样。

除了特殊行为之外，通常也应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率高。如果需要存储比秒更小粒度的日期和时间值，MySQL 目前没有提供合适的数据类型，但是可以使用自己的存储格式：可以使用 BIGINT 类型存储微妙级别的时间戳，或者使用 DOUBLE 存储秒之后的小数部分。这两种方式都可以，或者也可以使用 MariaDB 替代 MySQL。



#### 位数据类型

MySQL 有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如歌，从技术上来说都是字符串类型。

1、BIT

在 MySQL 5 之前，BIT 是 TINYINT 的同义词。但是 5 之后，这是一个特性完全不同的数据类型。可以使用 BIT 列在一列中存储一个或多个 true/ false 值。BIT(1) 定义一个包含单个位的字段，BIT(2) 存储两个位，以此类推。BIT 列的最大长度是 64 个位。

BIT 的行为因存储引擎不同而不同。MyISAM 会打包存储所有的 BIT 列，所以 17 个单独的 BIT 列只需要 17 个位存储，这样 MyISAM 只使用 3 个字节就能存储 17 个 BIT 列。其它存储引擎例如 Memory 和 InnoDB，为每个 BIT 列使用一个足够存储的最小整数类型来存放，所以不能节省存储空间。MySQL 把 BIT 当做字符串类型，而不是数字类型。当检索 BIT(1) 的值时，结果是一个包含二进制 0 或 1 的字符串，而不是 ASCII 码的 0 或 1。然而，在数字上下文的场景中检索时，结果将是位字符串转换成的数字。如果需要和另外一个值的比较结果，一定要记住这一点。如：存出一个值 b‘00111001’ 到 BIT(8) 的列并且检索它，得到的内容是字符码为 57 的字符串。

```mysql
create table bit_table(
	bit_column BIT(4)
);

insert into bit_table(bit_column)
values(b'1111'),
(b'0000');

select bit_column + 0 from bit_table;
```

结果：

```mysql
+----------------+
| bit_column + 0 |
+----------------+
|             15 |
|              8 |
+----------------+
```

正因为如此，所以我们认为应该谨慎使用 BIT 类型。对于大部分应用，最好避免使用这种类型。如果想在一个 BIT 的存储空间中存储一个 true/false 值，另一个方法是创建一个可以为空的 CHAR(0) 列。该列可以保存空值或者长度为 0 的字符串。



2、SET

如果需要保存很多 true/false 值，可以考虑合并这些列到一个 SET 数据类型，它在 MySQL 内部是以一系列打包的位的集合来表示的。这样就有效的利用了存储空间，并且 MySQL 有像 FIND_IN_SET() 和 FIELD() 这样的函数，方便的在查询中使用。它的主要缺点是改变列的定义和代价较高：需要 ALTER TABLE，这对大表来说是非常昂贵的操作。

在整数列上进行按位操作

一种替代 SET 的方式是使用一个整数包装一系列的位。例如，可以把 8 个位包装到一个 TINYINT 中，并且按位操作来使用。可以在应用中为每个位定义名称常量来简化这个工作。比起 SET，这种办法主要的喊出在于可以不使用  ALTER TABLE 改变字段代表的枚举值，缺点是查询语句更难写，并且更难理解。



#### 选择标识符

为标识列选择合适的数据类型非常重要。一般来说更有可能标识列与其它值进行比较，或者通过标识列寻找其他列。标识列也可能在另外的表中作为外键使用，所以标识列选择数据类型时，应该选择根关联表中的对应列一样的类型。

当选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑 MySQL 对这种类型怎么执行计算和比较。



### MySQL schema 设计中的陷阱

虽然有一些普遍的好或坏的设计原则，但也有一些问题是由 MySQL 的实现机制导致的，这意味着有可能犯一些只在 MySQL 中发生的特定错误。

1）太多的列

MySQL 的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过缓存行缓冲式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成数据结构的操作代价非常高的。MyISAM 的定长行结构实际上与服务器层的行结构正好匹配，所以不需要转换。然而，MyISAM 的变长行结构和 InnoDB 的行结构则总是需要转换，转换的代价依赖于列的数量。



2）太多的关联

所谓的 实体-属性-值 设计模式是一个常见的糟糕设计模式，尤其是在 MySQL 下不能靠谱的工作。MySQL 限制了每个关联操作最多只能有 61 张表，但是 EAV 数据库需要许多自关联。



3）全能的枚举

注意防止过度使用枚举，这种模式的 schema 设计非常凌乱。使用枚举类型也许在任何支持枚举类型的数据库都是一个有问题的设计方案，在 MySQL 中，当需要对枚举列表中新增一个选值时需要做一次 ALTER TABLE 操作。



4）变相的枚举

枚举列允许在列中存储一组定义值中的单个值，集合列则允许在列中存储一组定义值中的一个或多个值。



5）NULL

应该尽量不要使用 NULL。



### 范式和反范式

对于任何给定的数据通常都有很多种表示方法，从完全的范式化到完全的反范式化，以及两者的折中。在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范化的数据库中，信息是冗余的，可能会存储在多个地方。

#### 范式的优点和缺点

当为性能问题而寻求帮助时，经常会被建议对 schema 进行范式化设计，尤其是写密级的场景。这通常是个好建议，好处如下：

- 范式化的更新操作通常必反范式化更快。
- 当数据较好的范式化时，就只有很少或者没有重复数据，所以需要修改更少的数据。
- 范式化的表通常更小，可以更好的放在内存里，所以执行操作会更快。
- 很少有多余的数据意味着检索列表数据时更少需要 DISTINCT 或者 GROUP BY 语句。

范式化设计的 schema 的缺点通常是需要关联。关联的代价昂贵且有可能使一些索引策略失效。



#### 反范式化的优点和缺点

反范式化的 schema 因为所有数据都在一个表中，可以很好的避免关联。如果不需要关联表，则对大部分查询最差的情况：即使表没有使用索引（全表扫描）。当数据比内存大时，因为这样避免了随机 IO。单独的表也能使用更有效的索引策略。



#### 混用范式化和反范式化

事实上，完全的范式化和完全的反范式化 schema 都是实验室里才有的东西：在真实世界上很少会用这么极端的方式。在实际应用中经常需要混用，可能使用部分范式化的 schema、缓存表以及其它技巧。

最常见的反范式化数据的方法时复制或者缓存，在不同的表中存储相同的特定列。可以使用触发器更新缓存之，这使得实现这样的方案变得更简单。



### 存储表和汇总表

有时提升性能最好的方法时在同一张表中保存衍生的冗余数据，然而，有时也需要创建一张完全独立的汇总表或缓存表。如果能容许少量脏数据，这是非常好的方法，但是有时确实没有选择的余地，如：需要避免复杂、昂贵的实时更新操作。

缓存表和汇总表没有标准的定义，我们用缓存表来标识存储那些可以比较简单的从 schema 其它表获取数据的表。汇总表则保存的是使用 GROUP BY 等语句聚合的数据的表。

在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。那个更好依赖于应用程序，但是定期重建并不只是节省资源，也可以保持表不会有很多锁片以及有完全顺序组织的索引。

当重建汇总表和缓存表时，通常需要保证数据在操作时依然可用，这就可以通过使用 影子表 来实现，影子表 指的是一张在真实表背后创建的表。当完成了建表操作后，可以通过一个原子的重名名操作切换影子表和原表。



#### 物化视图

许多数据库管理系统都提供了一个被称为物化视图的功能。物化视图实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。MySQL 并不原生支持物化视图。



#### 计数器表

如果应用在表中保存计数器，则在更新计数器时可能碰到并发问题。计数器表在 web 应用中很常见。可以用这种表缓存一个用户的朋友数、文件下载次数等。创建一张独立的表存储计数器通常是一个好主意，这样可使计数器表小且快。使用独立的表可以帮助避免查询缓存失效。

问题在于，对于任何想要更新这一行的事务来说，这条记录都有一个全局的互斥锁。这回使得这些事务只能串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。



### 加快 ALTER TABLE 速度

MySQL 中 ALTER TABLE 操作的性能对大表来说是个问题。MySQL 执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这样操作可能需要花费很长时间，如果内存不足而表又很大，而且还有很多索引的情况下尤其如此。

一般而言，大部分 ALTER TABLE 操作将导致 MySQL 服务终端。避免的方法：先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库进行切换；另一种技巧是影子拷贝。影子拷贝的技巧使用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。



#### 只修改 .frm  文件

修改表的 .frm 文件是很快的，但 MySQL 有时候会在没有必要的时候也重建表，创建一个新的 .frm 文件，然后替换：

- 创建一张有相同结果的空表，并进行所需要的修改。
- 执行 FLUSH  TABLES WITH READ LOCK。这将会关闭所有正在使用的表，并且禁止人格表被打开。
- 交换 .frm  文件。
- 执行 UNLOCK TABLES 来释放上面的读锁。



#### 快速创建 MyISAM 索引

为了高效的载入数据到 MyISAM 表中，有一个常用的技巧是先禁用索引、载入数据，然后重新启用索引。这个技巧能发挥作用，是因为构件索引的工作被延迟到数据完全载入以后，这个时候已经可以通过排序来构建索引了。这样做会快很多，并且使得索引树的碎片更少、更紧凑。但是这个技巧对唯一索引无效，因为 DISABLE KEYS 只对非唯一索引有效。MyISAM 会在内存中构造文艺索引，并且为载入的每一行检查唯一性。一旦索引的大小超过了有效内存大小，载入操作就会变得越来越慢。



