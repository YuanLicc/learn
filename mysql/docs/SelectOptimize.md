## 查询优化

查询优化、索引优化、库表结构优化需要齐头并进，一个不落。在获得编写 MySQL 查询的经验的同时，也将学习到如何为高效的查询设计表和索引。也可以学到优化库表结构时会影响到哪些类型的查询。



### 为什么查询会慢

如果把查询看做一个任务，那么它有一系列子任务组成，每个子任务都会消耗时间。如果优化查询，实际上要优化其子任务，那么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行更快。MySQL 在执行查询的时候会存在很多子任务，很难给出完整的任务列表，但是可以将查询的生命周期大致分为：

```mysql
客户端  >>>  服务器 >>> 解析 >>> 生成执行计划 >>> 执行 >>> 返回结果
```

其中执行可以认为是整个生命周期中最重要的阶段，因为其中包含了大量为了检索数据到存储引擎的调用以及数据处理、排序及分组等。在执行这些任务时，花费时间包括网络、CPU 计算、生成统计信息、执行计划和锁等待等，尤其是向底层存储引擎检索数据的调用操作上消耗时间。根据存储引擎的不同，可能产生大量的上下文切换以及系统调用。

在每一个消耗大量时间的查询案例中，都能看到一些不必要的额外操作、某些操作被额外的重复了很多次、某些操作执行得太慢等。优化查询的目的就是减少和消除这些操作所花费的时间。



### 慢查询 - 优化数据访问

查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免的需要筛选大量数据，但这并不常见。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们总结以下两点：

- 确认应用程序是否在检索大量超过需要的数据。
- 确认 MySQL 服务器层是否在分析大量超过需要的数据行。



#### 是否请求了不需要的数据

1）查询不需要的记录。

2）多表关联时返回全部列。

3）总是取出全部列。

每次看到 select * 的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的列。

4）重复查询相同的数据。



#### 是否在扫描额外的记录

在确认只返回需要的数据以后，需要看查询是否为了返回结果而扫描了过多的数据，三个指标：

- 响应时间
- 扫描的行数
- 返回的行数

三个指标大致反映了 MySQL 在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间，这三个指标都会记录到 MySQL 的慢日志中。

1）响应时间

响应时间只是一个表面上的值，包含服务时间和排队时间。服务时间是指数据库处理这个查询真正画了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间。

2）扫描的行数和返回行数

理想情况下扫描的行数和返回的行数应该相同。但实际情况中这种没事并不多。一般扫描的行数与返回的行数比率在 1:1 到 10:1 之间。

3）扫描的行数和访问类型

可通过 explain 返回结果中分析。一般 MySQL 能够使用如下三种方式应用 where 条件：

- 在索引中使用 where 条件来过滤不匹配的记录，这是存储引擎完成的。
- 使用索引覆盖扫描来返回记录，直接从索引中过滤不需要的记录并返回命中结果。这是在 MySQL 服务器层完成的。
- 从数据表中返回数据，然后过滤不满足条件的记录。这是在服务器层完成的，需要先从数据表读取记录然后过滤。

如果发现查询需要扫描大量的数据但只返回少数的行，可以使用如下技巧优化：

- 使用索引覆盖扫描，把所需要的列放到索引中，这样存储引擎无需回表中获取对应行就可以了返回结果。
- 改变库表结构。
- 重写这个复杂的查询，让MySQL 优化器能够以更优化的方式执行这个查询。



### 重构查询的方式

在优化查询时，目标应该是找到一个更优的方法获得实际需要的结果，而不一定总是需要从 MySQL 获取一模一样的结果集。有时候可以将查询转换一种写法让其返回一样的结果，但是性能更好。但也可以通过修改应用代码，用另一种方式完成查询。

#### 一个复杂查询还是多个简单查询

设计查询的时候一个需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。在传统实现中，总是强调需要数据库层完成可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化是一件代价很高的事情。但是这样的想法对于 MySQL 并不适用，MySQL 从设计上连接和断开都是很轻量级的，在返回一个小的查询结果方面很高效。现代网络速度比以前要快得多，无论是带宽还是延迟。

MySQL 内部每秒能够扫描内存中上百万行数据，相比之下，MySQL 响应数据给客户端就慢得多了。在其他条件相同的时候，使用尽可能少的查询当然是更好的，但有时候，讲一个大查询分解为多个小查询时很有必要的。

#### 切分查询

对于一个大查询我们需要分而治之，将大查询切分为小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。

删除旧的数据就是一个很好的例子。定期清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、消耗系统资源、阻塞很多小的但很重要的查询。

#### 分解关联查询

很多高性能的应用都会对关联查询进行分解，简单的可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。



### 查询执行基础

当向 MySQL 发出一个请求时，MySQL 做了什么：

- 客户端发送一条查询给服务器。
- 服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。
- 服务器进行 SQL 解析、预处理，再由优化器生成对应的执行计划。
- MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。
- 将结果返回给客户端。

#### 客户端/ 服务器通信协议

客户端和服务器之间的通信协议是 “半双工” 的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。所以我们无法也无需将一个消息切成小块独立来发送。

这种协议让 MySQL 通信简单快速，但是也从很多地方限制了 MySQL。一个明显的限制是，这意味着没法进行流量控制。一旦一端开始发送消息，另一端要接收完整个消息才能响应它。

客户端用一个单独的数据包将查询传送给服务器。这也是为什么当查询的语句很长的时候，参数 max_allowed_packet 就特别重要了。相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整的接收真个返回结果，而不能简单的只去前面几条结果，然后让服务器停止发送数据。 

当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是 MySQL 在向客户端推送数据的过程。客户端不断地接收从服务器推送的数据，客户端也没法让服务器停下来。

多数连接 MySQL 的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL 通常需要等所有的数据都已经发送到客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束、早点释放响应的资源。

当使用多数连接 MySQL 的库函数从 MySQL 获取数据时，其结果看起来都像是从 MySQL 服务器获取数据，而实际上都是从这个库函数的缓存获取数据。多数情况下这没什么问题，但是如果需要返回一个很大的结果集的时候，这样做并不好，因为库函数会花费很多时间和内存来存储所有的结果集。如果能够尽早开始处理这些结果集，就能大大减少内存的消耗，这种情况下可以不使用缓存来记录结果而是直接处理。这样做的缺点是，对于服务器来说，需要查询完成后才能释放资源，所以和客户端交互的整个过程中，服务器的资源都是被这个查询所占用的。

#### 查询状态

对于一个 MySQL 连接，或者说一个线程，任何时刻都有一个状态，该状态表示了 MySQL 当前正在做什么。有很多方式能查看当前状态，最简单的是使用 show full processlist 命令。在一个查询的生命周期中，状态会变化很多次，状态如下：

- Sleep

  线程正在等待客户端发送新的请求。

- Query

  线程正在执行查询或者正在将结果发送给客户端。

- Locked

  线程正在等待表锁。

- Analyzing and statics

  线程正在收集存储引擎的统计信息，并生成查询的执行计划。

- copying to tmp table [on disk]

  线程正在执行查询，并且将其结果集都复制到一个临时表中。on disk 表示 MySQL 正在将一个内存临时表放到磁盘上。

- thr thread is

  线程正在对结果集进行排序。

- sending data

  这表示多种情况：线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。

#### 查询缓存

在解析一个查询语句之前，如果查询缓存是打开的，那么 MySQL 会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有有个字节不同，那也不会匹配缓存结果。

如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前 MySQL 会检查一次用户权限，这任然是无需解析查询 SQL 语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题，MySQL 会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行。

#### 查询优化处理

查询的生命周期的下一步是将一个 SQL 转换成一个执行计划，MySQL 再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析 SQL、预处理、优化 SQL执行计划。这个过程中任何错误都可能终止查询。

1、语法解析器和预处理

首先，MySQL 通过关键字将 SQL语句进行解析，并生成一棵对应的解析树。MySQL 解析器将使用 MySQL 语法规则验证和解析查询。例如，他将验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，再或者它还会验证引号是否能前后正确匹配。

预处理器则根据一些 MySQL 规则进一步检查解析树是否合法，例如，这里将检查数据表和数据列是否存在，还会解析名字和别名。

下一步预处理器会验证权限。这通常很快，除非服务器上有很多的权限配置。

2、查询优化器

现在语法树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。

MySQL 使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。最初，成本的最小单位是随机读取一个 4k 数据页的成本，后来变得更加复杂，并且引入了一些因子来估算某些操作的代价。有很多原因会导致 MySQL 优化器选择错误的执行计划：

- 统计信息不准确。MySQL 依赖存储引擎提供的统计信息来评估成本，但是有的存储引擎提供的信息是准确的，有的偏差很大。如：InnoDB 因为其 MVCC 的架构，并不能维护一个数据表的行数的精确统计信息。
- 执行计划中的成本估算不等于实际执行得成本。所以即使统计信息准确，优化器给出的执行计划也可能不是最优的。
- MySQL 的最优可能和你想的最优不一样。你可能希望执行时间尽可能的短，但是 MySQL 只是基于其成本模型选择最优的执行计划，而有些时候这并不是最快的执行方式。
- MySQL 从不考虑其他并发执行的查询，这可能会影响到当前查询速度。
- MySQL 也并不是任何时候都是基于成本的优化。有时也会基于一些固定的规则，例如，如果存在全文搜索的 MATCH() 子句，则在存在全文索引的时候就使用全文索引。即使有时候使用别的索引和 where 条件可以远比这种方式要快，MySQL 也仍然会使用对应的全文索引。
- MySQL 不会考虑不受其控制的操作的成本，例如执行存储过程或者用户自定义函数的成本。
- 优化器有时候无法去估算有可能的执行计划，所以他可能错过实际上最优的执行计划。

MySQL 的查询优化器是一个非常复杂的部件，它使用了很多优化策略来生成一个最优的执行计划。优化策略可以简单的分为两种：静态优化、动态优化。静态优化可以直接对解析树进行分析，并完成优化。动态优化和查询的上下文有关，也可能和很多其他因素有关，例如 where 条件的取值、索引中条目对应的数据行数等。

在执行语句和存储过程的时候，动态优化和静态优化的区别非常重要。MySQL 对查询的静态优化只需要做一次，但对查询的动态优化则在每次执行时都需要重新评估。下面是 MySQL 能够处理的优化类型：

1）重新定义关联表的顺序

数据表的关联并不总是按照在查询中指定的顺序进行。决定关联的顺序是优化器很重要的一部分。

2）将外连接转化成内连接

并不是所有的 outer join 语句都必须以外连接的方式执行。

3）使用等价变换规则

MySQL 可以使用一些等价变换来简化并规范表达式。它可以合并和减少一些比较，还可以一出一些恒成立和一些恒不成立的判断。

4）优化 count()、min()、max()

索引和列是否可为空通常可以帮助 MySQL 优化这类表达式。

5）预估并转化为常数表达式

当 MySQL 检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。

6）覆盖索引扫描

当索引中的列包含所有查询中需要使用的列的时候，MySQL 就可以了使用索引返回需要的数据，而无需查询对应的数据行。

7）子查询优化

MySQL 在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问。

8）提前终止查询

在发现已经满足查询需求的时候，MySQL 总是能够立刻终止查询。

9）等值传播

如果两个列的值通过等式关联，那么 MySQL 能够把其中一个列的 where 条件传递到另一个列上。

10）列表 in() 的比较

在很多数据库系统中，In() 完全等同于多个 or 条件的子句，因为这两者是完全等价的。在 MySQL 中这点事不成立的，MySQL 将 in() 列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个 O(logn) 复杂度的操作，等价的转换成 Or 查询的复杂度是 O(n)，对于 IN() 列表中有大量取值的时候，MySQL 的处理速度将会更快。

3、数据和索引的统计信息

在服务器层有查询优化器，却没有保存数据和索引的统计信息。统计信息由存储引擎实现，不同的存储引擎可能会存储不同的统计信息。

因为服务器层没有任何统计信息，所以 MySQL 查询优化器在生成查询的执行计划时，需要向存储引起获取相应的统计信息。存储引擎则提供给优化器对应的统计信息，包括：每个表或索引有多少个页面、每个表的每个索引的基数是多少、数据行和索引长度、索引的分部信息等。

4、MySQL 如何执行关联查询

MySQL 认为任何一个查询都是一次关联，并不仅仅是一个查询需要到两个表匹配才叫关联，所以在 MySQL 中，每一个查询，每一个片段（子查询、单表的 select）都可能是关联。理解 MySQL 如何执行关联查询至关重要。

对于 Union 查询，MySQL 先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成 UNION 查询。在 MySQL 概念中，每个查询都是一次关联，所以读取结果临时表也是一次关联。

当前 MySQL 关联执行得策略很简单：MySQL 对任何关联都执行嵌套循环关联操作，即 MySQL 现在一个表中循环去除单挑数据，然后再嵌套循环到下一个表中寻找匹配的行，一次下去，知道找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。MySQL 会尝试找到最后一个关联表中找到所有匹配的行，如果最后一个联表无法找到更多的行以后，MySQL 返回到上一层次关联表，看师傅能够找到更多的匹配记录，以此类推迭代执行。

 5、执行计划

和很多其他关系型数据库不同，MySQL 并不会生成查询字节码来执行查询。MySQL 生成查询的一棵指令树，然后通过存储引擎执行完成这可指令树并返回结果。最终的执行计划包含了重构查询的全部信息。如果对某个查询执行 explain extended 后，再执行 show warnings，就可以了看到重构出的查询。

6、关联查询优化器

MySQL优化器最重要的一部分就是关联查询优化，它决定了多个表关联时的顺序。通常多表关联的时候，可以有多种不同的关联顺序来获得相同的执行结果。关联查询优化器则通过评估不同顺序时的成本来选择一个代价最小的关联顺序。

7、排序优化

无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序。MySQL 当不能使用索引生成排序结果的时候，需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘。MySQL 有如下排序算法：

- 两次传输排序

  读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。这需要进行两次数据传输，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这回产生大量的随机 I/O，所以两次数据传输的成本非常高。当使用的是 MyISAM 表时，成本可能会更高，因为 MyISAM 使用系统调用进行数据的读取。

- 单次传输排序

  县杜曲查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。

MySQL 在进行大文件排序的时候需要使用的临时存储空间可能比想象的要大得多。原因在于 MySQL 在排序时，对每一个排序记录都会分配一个足够长的定长空间来存放。这个定长空间必须足够长以容纳其中最长的字符串。

在关联查询的时候如果需要排序，MySQL 会分两种情况来处理这样的文件排序。如果 order by 子句中的所有列都来自关联的第一个表，那么 MySQL 在关联处理第一个表的时候就进行文件排序。



#### 查询执行引擎

在解析和优化阶段，MySQL 将生成查询对应的执行计划，MySQL 的查询执行引擎则根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和很多其他关系型数据库那样会生成对应的字节码。

相对于查询优化阶段，查询执行阶段不是那么复杂：MySQL 只是简单的根据执行计划给出的指令逐步执行。在此过程中，有大量的操作需要通过调用存储引擎实现的接口来完成，这些接口也就是我们称为 handler API 的接口。查询中的每一个表由一个 handler 的实列表示。

存储引擎接口有着非常丰富的功能，但是底层接口却只有几十个，这些接口像搭积木一样能够完成查询的大部分操作。为了执行查询，MySQL 只需要重复执行计划中的各个操作，直到完成所有的数据查询。

#### 返回结果给客户端

查询执行的最后一个阶段是将结果返回给客户端，即使查询不需要返回结果集给客户端，MySQL 仍然会返回这个查询的一些信息，如查询影响的行数。

如果查询可以被缓存，那么MySQL 在这个阶段也会将结果存放到查询缓存中。

MySQL 将结果集返回客户端是一个增量、逐步返回的过程。如，服务器在生成第一条结果时，MySQL 就可以了开始想客户端逐步返回结果集了。这样处理有两个好处：

- 服务器端无须存储太多的结果，也就不会因为要返回太多结果而消耗太多内存。另外，这样的处理也让 MySQL 客户端第一时间获得返回的结果。
- 结果集中的每一行都会以一个满足 MySQL 客户端/ 服务器通信协议的封包发送，再通过 TCP 协议进行传输，在 TCP 传输过程中，可能对 MySQL 的封包进行缓存然后批量传输。



### 查询优化器的局限

MySQL 的万能嵌套循环并不是对每种查询都是最优的。不过还好，MySQL 查询优化器只对少部分查询不适用，而且我们往往可以通过改写查询让 MySQL 高效的完成工作。

#### 关联子查询

MySQL 的子查询实现得非常糟糕。最糟糕的一类查询是 where 条件中包含 in() 的子查询语句。因为 MySQL 对 in() 列表中的选项有专门的优化策略。

1）如何用好关联子查询

并不是所有关联子查询的性能都会很差。

#### union 的限制

有时，MySQL 无法限制条件外层下推到内层，这使得原本能够限制部分返回结果的条件无法应用到内层查询的优化上。如果希望 union 的各个子句能够根据 limit 只取部分结果集，或者希望先排好序再合并结果集的话，就需要再 union 的各个子句中分别使用这些子句。

#### 索引合并优化

当 where 子句中包含多个复杂条件的时候，MySQL 能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。

#### 等值传递

某些时候，等值传递会带来一些意想不到的额外消耗。

#### 并行执行

MySQL 无法利用多核特性来并行执行查询。

#### 哈希关联

MySQL 并不支持哈希关联。

#### 松散索引扫描

MySQL 并不支持松散索引扫描，也就无法按照不连续的方式扫描一个索引。

#### 最大值和最小值优化

对于 min、max 查询，MySQL 的优化做得并不好。

#### 在同一个表上查询和更新

MySQL 不允许对同一张表同时进行查询和更新。这其实并不是优化器的限制，如果清除 MySQL 是如何执行查询的，就可以了避免这种情况。



### 查询优化器的提示

如果对优化器选择的执行计划不满意，可以使用优化器提供的几个提示来控制最终的执行计划。

1）HIGH_PRIORITY 和 LOW_PRIORITY

这个提示告诉 MySQL，当多个语句同时访问某一个表的时候，哪些语句的优先级相对高些、哪些语句的优先级相对低些。HIGH_PRIORITY 用于 SELECT 语句的时候，MySQL 会将此 SELECT 语句重新调度到所有正在等待表锁以便修改数据的语句之前。实际上 MySQL 是将其放在表的队列的最前面，而不是按照常规顺序等待。HIGH_PRIORITY 还可以用于 insert 语句，其效果只是简单的抵消了全局 LOW_PRIORITY 设置对该语句的影响。

LOW_PRIORITY 则正好相反：它会让该语句一直处于等待状态，只要队列中海油需要访问同一个表的语句，即使是那些比该语句还晚提交到服务器的语句。这就像一个过于礼貌的人站在餐厅门口，只要还有其它顾客在等待就一直不进去，很明显这容易把自己给饿坏。LOW_PRIORITY 提示在 SELECT、INSERT、DELETE语句中都可以使用。