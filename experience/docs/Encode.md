## 编码相关、国际化





## 概念

### Unicode

很多人都把 `Unicode` 编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是 `Unicode` 的。因为 `Unicode` 兼容了大多数老版本的编码规范例如  `ASCII` 。 `Unicode` 编码定义了这个世界上几乎所有字符（就是你眼睛看到的长那个样子的符号）的数字表示。也就是说 `Unicode` 为每个字符发了一张身份证，这张身份证上有一串唯一的数字ID确定了这个字符在这个纷乱世界上存在的唯一性。 `Unicode` 给这串数字 `ID` 起了个名字叫 [码点 ] （`Code Point`）而很多人说的编码其实是想表达 [ `Unicode`  转换格式 ] （即`UTF`， `Unicode  Transformation Formats`）。有没有觉得眼前一亮豁然开朗？没错这就是我们看到的 `UTF-8/UTF-16/UTF-32` 的前缀来源。

这个 [ `Unicode` 转换格式 ] 的存在是为了解决 [码点 ] 在计算机中的二进制表现形式而设计的。毕竟我们的机内表示涉及存储位宽、兼容古老编码格式。[码点] 经过映射后得到的二进制串的转换格式单位称之为 [码元 ] （`Code Unit`）。也就是说如果有一种 `UTF` 的码点二进制表示有 n 字节，其码元为 8 位（1个 `byte`），那么其拥有码元n 个。每种 `UTF` 的码元都不同，其宽度被作为区分写在了 `UTF` 的后缀——这就是 `UTF-8/UTF-16/UTF-32` 的由来。

`UTF-8` 的码元是 8 位的，`UTF-16` 的码元是 16 位的。大部分的编程语言采用 16 位的码元作为机内表示。这就是我们在各种语言中调用获取一个字符串中 `character` 的数量时会出现这么多混乱的原因。事实上我们调用这些方法时取得的不是字符个数，而是码元个数！一旦我们的字符串中包含了位于基本平面之外的码点，那么就会需要更多的码元来表示，这个时候就会出现测试时常见的困惑——为何 `return` 的字符数比实际字符数要多？所以实际写代码时要特别注意这个问题。

采取不同的映射方式可以得到不同格式的二进制串，但是他们背后所表示的 [码点 ] 永远是一致的就好像你换身份证但是身份证号不变一样。由于平时人们误把 [转换格式 ] 也称为 [编码 ] ，所以造成今天 `Unicode／UTF` 傻傻分不清楚且遣词造句运用混乱的悲桑局面。

 `Unicode`  编码发展到今天扩展到了 21 位（从 `U+0000` 到 `U+10FFFF` ）。这一点很重要：  `Unicode`  不是 16 位的编码， 它是 21 位的。这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，所以还有相当大的扩充空间。

编码空间被分成 17 个平面（`plane`），每个平面有 65,536 个字符（正好填充2个字节，16位）。0 号平面叫做「基本多文种平面」（`BMP, Basic Multilingual Plane` ），涵盖了几乎所有你能遇到的字符，除了 `emoji`（`emoji`位于1号平面）。其它平面叫做补充平面，大多是空的。

#### UTF-32

最清楚明了的一个 `UTF` 就是 `UTF-32` ：它在每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。

#### UTF-16 以及「代理对」（ Surrogate Pairs ）的概念

`UTF-16` 要常见得多，它是根据有 16 位固定长度的码元（`code units `）定义的。`UTF-16` 本身是一种长度可变的编码。基本多文种平面（`BMP`）中的每一个码点都直接与一个码元相映射。鉴于 `BMP` 几乎囊括了所有常见字符，`UTF-16` 一般只需要 `UTF-32` 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做代理对（`surrogate pair`）。

#### UTF-8

`UTF-8` 使用一到四个字节来编码一个码点。从 0 到 127 的这些码点直接映射成 1 个字节（对于只包含这个范围字符的文本来说，这一点使得 `UTF-8` 和 `ASCII` 完全相同）。接下来的 1,920 个码点映射成 2 个字节，在 `BMP` 里所有剩下的码点需要 3 个字节。 `Unicode`  的其他平面里的码点则需要 4 个字节。`UTF-8` 是基于 8 位的码元的，因此它并不需要关心字节顺序（不过仍有一些程序会在 `UTF-8` 文件里加上多余的 `BOM`）。

有效率的空间使用（仅就西方语言来讲），以及不需要操心字节顺序问题使得 `UTF-8` 成为存储和交流  `Unicode`  文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了。

我们的 `JVM` 中保存码点是 `UTF16` 的转换格式，从 `char` 的位宽为 16 位也可以看得出来。由于绝大部分编码的码点位于基本平面，所以使用 16 位可以几乎表示所有常用字符。这就是许多语言编译器或运行时都使用 `UTF16` 的原因。英文在使用 `UTF16` 时也是 2 字节表示的。当我们想要使用其他平面的字符时，码元超过2个字节，就需要使用代理对在语言中的特定表示方式，譬如 ‘\U112233’ 之类的。

使用 `UTF8` 时，常用的 `Alphabet` 和 `Numeric` 都在前 127 字节，被有效率地用一个字节表示。而我们的中文由于排在 1920 个码点之后，所以使用 3 个字节表示，这方面就比 `UTF16` 转换格式耗费更多空间。

最后，不论使用哪种 `UTF` 转换格式，都是程序员自己可以选择的一种表达方式而已。我们可以通过 `Java` 方便的 `API` 进行自如转换。



### Java 中字符占几个字节？

`Java` 默认使用 `Unioncode` 编码，即不论什么语言都是一个字符占两个字节。`Java` 的 `class` 文件编码为 `UTF-8`，而虚拟机 `JVM` 编码为 `UTF-16`。`UTF-8` 编码下，一个中文占 3 个字节，一个英文占 1 个字节。`Java` 中的 `char` 默认采用 `Unicode` 编码，所以 `Java` 中 `char` 占 2 个字节。1(`byte`)字节 = 8(`bit`)位。