## 概念

---

### 1.类的生命周期

类从被加载到虚拟机内存开始,到卸载为止,整个生命周期包括:加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个部分统称为连接。 

### 2.加载 

加载是类加载过程的一个阶段,在该阶段它需要完成三件事情：

(1) 通过一个类的全限定名来获取定义此类的二进制字节流。

(2) 将这个字节流所代表的静态结构转化为方法区的运行时数据结构。

(3) 在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据访问的入口。

首先,由第一条我们可以看到JVM只是要求通过全限定类名来获取定义此类的二进制字节流,而并没有指明二进制字节流从哪里获取,通过Class文件?网络?数据库?并没有做过多的限制。

另外Class对象比较特殊,它虽然是对象,但是存放在方法区中。

加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束,连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，加载阶段和连接阶段的开始时间仍然保持着固定的先后顺序。

数组类由Java虚拟机直接创建，创建动作由字节码指令newarray触发。但是数组类仍然与类加载器有很密切的联系，因为它的元素类型最终要靠类加载器去创建。一个数组类的创建过程遵循以下规则：

（1）如果数组的组件类型是引用类型，那就递归采用加载过程去加载这个组件类型，数组将在加载该组件类型的类加载器的命名空间上被标识。

（2）如果数组的组件类型不是引用类型，Java虚拟机将会把数组标记为与引导类加载器关联。

（3）数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public

### 3.验证 

这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全。

(1) 文件格式验证

该验证阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区之内。

(2) 元数据验证

第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。

(3) 字节码验证

这个阶段对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事情。

(4) 符号引用验证

发生在虚拟机将符号引用转化为直接引用的时候，这转化动作将在解析阶段完成。

### 4.准备

准备阶段是正式为类变量(静态变量)分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这里仅仅是为类变量设置默认值，而不是指定值。但是该阶段会为静态常量设置指定值。

### 5.解析 

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

符号引用：

以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号		 	

引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。

直接引用：

可以直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局 

相关的。如果有了直接引用，那引用的目标必定已经在内存中存在。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

### 6.初始化

在准备阶段,类变量已经赋过一次系统要求的初始值,而在初始化阶段,则根据程序员通过程序制定的主观计划去初始化类变量和其他资源,换句话说,初始化阶段是执行类构造器`<clinit>`方法的过程.

`<clinit>`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的,编译器的收集顺序是由语句在源文件中出现的顺序决定的,静态语句块中只能访问定义在它之前的变量,定义在它之后的变量,可以赋值但是不能访问.

对于初始化阶段,虚拟机规范严格规定了有且只有五种情况必须立即对类进行初始化：

(1) 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时,如果类没有进行过初始化,则需要先触发其

初始化。这四条指令常见的Java场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候、以及调用一个类的静态方法的时候。

(2) 使用java.lang.reflect包进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

(3) 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

(4) 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个类。

(5) 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析的结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类还没有进行过初始化，则需要先触发其初始化。

这5种场景中的行为成为对一个类进行主动引用。除此之外，所有引用类的方式都不会出发初始化，称为被动引用。