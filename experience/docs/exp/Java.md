#### 飞书

- 项目中的 AOP，具体怎么实现的？

- undolog、redolog、binlog 的区别？

- 讲讲事务隔离级别，MVCC 的优缺点？

  - 读未提交：可以读到其它事务未提交的数据
  - 读已提交：可以读到其它事务提交的数据，一般生产环境选择此隔离级别
  - 可重复读：保证事务中看到的数据视图的一致性，但是不能解决幻读（也就是新增的行数据）
  - 串行化：事务之间串行化执行

  MVVC 

  - 优点：通过undolog 来实现多版本视图，在数据读取上避免了同步操作
  - 缺点：维护 undolog 日志段需要资源耗费，在长事务中，可能导致 undolog 得不到释放，增加内存压力

- MySQL的默认隔离级别是什么？

  可重复读

- 可重复隔离读级别怎么实现的？

  通过MVCC实现可重复读，对于写操作，都是通过锁实现

  - 数据行中保存着隐藏字段：事务ID 及 指向 undolog 的指针
  - 根据指针进行数据回溯以生成 readview
  - 对于当前事务来说，看到的都是确定的 readview，也就保证了可重复读

- Redis 持久化，AOF 和 RDB 的区别？

  我认为 Redis 的持久化时 AOF 实现的，类似于Innodb 中的 redolog，只不过 AOF 是写后日志，通常可以根据策略选择 每次都刷盘、间隔时间刷盘或交由系统自动刷盘来保证数据的不丢失

  - AOF 是日志数据，写时同redolog可以进行顺序写入，减少寻址；相对而言日志的写肯定会造成磁盘占用更大
  - RDB 是对内存数据的快照备份，通常是定时备份或主从复制中启用；相对AOF而言，磁盘占用小，数据恢复快

  生产环境中可通过定期的 RDB 备份及增量的 AOF 进行数据持久化，以减少磁盘占用以及数据的快速恢复

- JVM 中为什么要分为新生代、老年代？

  大多数对象的生命周期较短（基本都不会逃离方法的作用范围），也就是新对象的回收率比较高；而存活较久的对象要么伴随程序的整个生命周期，要么是执行时间较长的动作，均带有长时间不需要回收的特性；进行分代：

  1）能够针对性的设计回收算法提高回收效率

  2）能够方便进行内存管理

- 用户量大的情况，Gateway 轮询压力大怎么解决？

  - 考虑切换为随机分配，因为请求多的情况，随机也不会导致明显的部分承压，趋近于均分

  - 利用服务发现搭配 Ngnix 实现 Gateway 多实例部署

- 线程池机制、核心参数、拒绝策略？

  - 机制：任务提交时，先判断核心线程数，如果无空闲则进入阻塞队列，如果阻塞队列满，则创建救急线程，如果救急线程满则执行拒绝策略
  - 核心参数：核心线程数，一旦创建不会释放；总线程数 = 核心线程数 + 救急线程数；救急线程闲置存活时间；存活时间的单位；阻塞队列，用于存放任务并且提供线程的阻塞能力；拒绝策略
  - 拒绝策略：直接拒绝、拒绝并报错、利用调用方线程执行任务、移除等待最久的任务

- MySQL 中，优化器选错了索引，怎么解决？

  优化器选错索引，通常是因为优化器判断走索引扫描的行数（包含回表）比走全表扫描行数更多，比如两个事务中一个事务进行了大量的数据增删，可能会导致同一时期的另一个事务误判扫描行数；在深分页查询中，优化器判断走索引需要扫描排除的数据多且需要回表操作，那么会选择全表扫描

  - 可以通过子查询来解决，子查询中只查询主键ID即可
  - 可以考虑覆盖索引
  - 可以考虑SQL中显示的使用索引（不推荐、不易维护）

- 创建索引需要考虑什么问题？

  1）考虑数据量：数据量小时，不需要创建索引，增加索引维护的负担

  2）考虑对经常使用的筛选列、聚合列、排序列进行索引创建

  3）索引创建不宜过多、索引列不宜过多（高瘦索引，IO较多）、索引列不宜过长（高瘦索引，IO较多）

  4）联合索引时，可以考虑覆盖查询，但是要考虑前面的约束；另外就是需要按照列的常用性进行排序创建联合索引，特别是动态查询场景下；还需要考虑对于索引列中需要模糊查询的列应该放在最后

- 分布式锁加锁失败后的等待逻辑怎么实现的？

  没有看过源码，但是我认为分布式环境下，由于不在一个环境下，所以不能依赖被动唤醒，需要通过 park 指定时间来进行等待，这个park 的时间不能超过 key 的过期剩余时间

- 如何降低软件复杂度？



- 如何设计一个敏感数据存储和传输安全加密平台？

- ThreadLocal 参数如何传递，线程池如何传递？

  通过set方法，会获取当前的线程对象，并获取线程对象的 map 对象，若为空则初始化并进行 set 操作，所以根本上是每个线程对象自己的成员变量

  线程池中由于核心线程一旦创建那么不会被销毁，如果 value 被强引用且没有被释放，那么会造成 value 得不到释放，造成内存泄漏

- Netty 比原生的IO模型优势？

- 高并发下写数据为什么不推荐关系数据库？

  关系型数据库由于存在级联外键关系，当写入时需要判断主表的主键是否存在，所以不推荐，通常生产环境中都不建议使用级联关系，可以保存主表外键，但是并不设置级联关系

- 什么是内存溢出与内存泄漏？

  内存溢出是指尝试申请无法分配的内存资源

  内存泄漏是指占用的内存资源得不到释放

- RR 隔离级别的实现，如何解决不可重复读？

- Nacos 的选举机制是什么？Raft 算法？

  Nacos 采用 Raft 算法来进行选举以保证高可用

  - 当触发选举条件时会开启选举行为：集群内无 leader、leader 下线、集群成员变化
  - 此时集群成员转化为candidate角色，开始申请选举，首先 candidate 会给自己投票
  - candidate 向其它成员申请选举投票，其它节点根据 candidate 的任期号及日志完整度进行投票
  - 当投票数超过一半时，表示 candidate 可以作为集群 leader

- Kafka 的消费者可能有哪些状态，高水位是什么？

  消费者状态

  - dead 状态 - 表示消费者尝试获取消息时发生异常并无法正常工作
  - empty 状态 - 表示消费者尝试获取数据时，未获取到任何数据
  - rebalance 状态 - 表示消费者处于重平衡状态，此时消费者将停止获取数据，由Kafka的协调者进行重平衡操作，分配消费者组内订阅的topic的所有分区到组内的消费者
  - complete rebalance 状态 - 表示完成了重平衡过程
  - stable 状态 - 表示处于稳定运行状态

  高水位

  - 表示的是分区内数据的可见性，消费者只能消费高水位之前的数据，高水位之后的数据通常表示还未提交的数据，所以不能进行拉取消费
  - 另外高水位的更新跟提交有关，提交后高水位也同步更新

- MySQL 主从同步延迟怎么解决？

  - 提高主库和从库的资源以提高性能
  - 调整从库同步的并行度
  - 启用GTID复制

- Dubbo 的服务请求失败怎么解决？

- MySQL CPU 飙升，怎么处理？

  MySQL 作为一个数据库，计算方面的支持不是瓶颈所在，所以一般 CPU 飙升可能是请求过多且请求可能为长事务导致，一般还伴随着内存占用变多场景

  - 通过 show processlist 来查看执行列表，判断是否为请求过多造成
  - 生产环境中通过三方监控软件查看慢查询SQL
  - explain 进行分析处理

- MQ 的作用？幂等和重复问题？消息丢失怎么解决？

  - Kafka 中幂等性保障可以通过设置幂等性生产者来实现，维护一个自增的ID来判定是否重复提交数据
  - 消费端重复消费问题，必须保证先消费，再提交，可以选择同步提交，不能选择自动提交，另外为了保证Kafka 的稳定性，定期拉取的间隔不能过短，所以最好还是自己代码内维护检查点来保存消费的 offset
  - 消息丢失应该是出现在生产者中，在发送到 leader 后，leader 宕机导致的数据丢失，可以在生产端设置ack来保证或者采用ISR同步

- Get、Put、Post 区别？谁是幂等的？详细讲讲幂等

  - GET 方法用于请求获取服务器资源，请求方式是通过URL携带数据，安全性较差，具有幂等性
  - PUT 方法用于创建或者更新资源，请求方式是通过请求体携带数据，安全性较GET高，需要保证幂等性
  - POST 方法用于提交数据或文件处理，请求方式是通过请求体携带数据，安全性较GET高，不需要保证幂等性

  幂等性简单理解就是多次提交相同的请求返回的结果一致且对于服务器资源来说，只会有一次修改操作

