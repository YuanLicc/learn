## JVM 相关

### 1. 64 位 JVM 中，int 的长度是多数？

Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。



### 2. Serial 与 Parallel GC之间的不同之处？

Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。



### 3. 32 位和 64 位的 JVM，int 类型变量的长度是多数？

32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。 



### 4. JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？

当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。 



### 5. 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？

你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。 



### 6. 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？

理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。 



### 7. 解释 Java 堆空间及 GC？

当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。 



### 8. 你能保证 GC 执行吗？

不能，虽然你可以调用 System.gc() 或者 Runtime.getRuntime().gc()，但是没有办法保证 GC 的执行。



### 9. 怎么获取 Java 程序使用的内存？堆使用的百分比？

可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。



### 10. Java 中堆和栈有什么区别？

JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。 



### 11. JVM的内存结构

主要分为三大块 堆内存、方法区、栈；栈又分为JVM栈、本地方法栈

- 堆（heap space），堆内存是JVM中最大的一块，有年轻代和老年代组成，而年轻代又分为三分部分，Eden区，From Survivor，To Survivor，默认情况下按照8:1:1来分配
- 方法区（Method area），存储类信息、常量、静态变量等数据，是线程共享的区域
- 程序计数器（Program counter Register），是一块较小的内存空间，是当前线程所执行的字节码的行号指示器

- JVM栈（JVM stacks），也是线程私有的，生命周期与线程相同，每个方法被执行时都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息
- 本地方法栈（Native Mthod Stacks）,为虚拟机使用的native方法服务



### 12. 关于垃圾回收和常见的GC算法

[GC专家系列-理解java垃圾回收](https://segmentfault.com/a/1190000004233812)



### 13 什么是堆和栈，它们在哪儿？

​	栈是为执行线程留出的内存空间。当函数被调用的时候，栈顶为局部变量和一些 bookkeeping 数据预留块。当函数执行完毕，块就没有用了，可能在下次的函数调用的时候再被使用。栈通常用后进先出（LIFO）的方式预留空间；因此最近的保留块（reserved block）通常最先被释放。这么做可以使跟踪堆栈变的简单；从栈中释放块（free block）只不过是指针的偏移而已。

​	堆（heap）是为动态分配预留的内存空间。和栈不一样，从堆上分配和重新分配块没有固定模式；你可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变的异常复杂；有许多定制的堆分配策略用来为不同的使用模式下调整堆的性能。

​	每一个线程都有一个栈，但是每一个应用程序通常都只有一个堆（尽管为不同类型分配内存使用多个堆的情况也是有的）。

1. 当线程创建的时候，操作系统（OS）为每一个系统级（system-level）的线程分配栈。通常情况下，操作系统通过调用语言的运行时（runtime）去为应用程序分配堆。
2. 栈附属于线程，因此当线程结束时栈被回收。堆通常通过运行时在应用程序启动时被分配，当应用程序（进程）退出时被回收。
3. 当线程被创建的时候，设置栈的大小。在应用程序启动的时候，设置堆的大小，但是可以在需要的时候扩展（分配器向操作系统申请更多的内存）。 
4. 栈比堆要快，因为它存取模式使它可以轻松的分配和重新分配内存（指针/整型只是进行简单的递增或者递减运算），然而堆在分配和释放的时候有更多的复杂的 bookkeeping 参与。另外，在栈上的每个字节频繁的被复用也就意味着它可能映射到处理器缓存中，所以很快（译者注：局部性原理）。

**Stack:**

1. 和堆一样存储在计算机 RAM 中。
2. 在栈上创建变量的时候会扩展，并且会自动回收。
3. 相比堆而言在栈上分配要快的多。
4. 用数据结构中的栈实现。
5. 存储局部数据，返回地址，用做参数传递。
6. 当用栈过多时可导致栈溢出（无穷次（大量的）的递归调用，或者大量的内存分配）。
7. 在栈上的数据可以直接访问（不是非要使用指针访问）。
8. 如果你在编译之前精确的知道你需要分配数据的大小并且不是太大的时候，可以使用栈。
9. 当你程序启动时决定栈的容量上限。

**Heap：**

1. 和栈一样存储在计算机RAM。
2. 在堆上的变量必须要手动释放，不存在作用域的问题。数据可用 delete, delete[] 或者 free 来释放。
3. 相比在栈上分配内存要慢。
4. 通过程序按需分配。
5. 堆是在任何内存中动态和随机分配的（内存的）统称；也就是无序的。内存通常由操作系统分配，通过应用程序调用 API 接口去实现分配。在管理动态分配内存上会有一些额外的开销，不过这由操作系统来处理。 
6. 大量的分配和释放可造成内存碎片。
7. 在 C++ 中，在堆上创建数的据使用指针访问，用 new 或者 malloc 分配内存。
8. 如果申请的缓冲区过大的话，可能申请失败。
9. 在运行期间你不知道会需要多大的数据或者你需要分配大量的内存的时候，建议你使用堆。
10. 可能造成内存泄露。



## Java内存模型

### 1.硬件的效率与一致性

为了提高计算机处理器的利用率，现代计算机在处理器与内存之间引入了一层读写速度尽可能靠近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速执行，当运算结束后再从缓存同步回内存之中。

但是上述方案又引入了一个新的问题——缓存一致性。在多处理器的系统中，每个处理器都有自己的高速缓存，而它们又共享同一块主内存，当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时根据协议来操作。

因此**内存模型**可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。

除了增加高速缓存外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不能保证程序中各个语句计算的先后顺序与代码中的输入顺序一致，因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序优化。

### 2.Java内存模型

Java内存模型是用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。Java内存模型并没有限制执行引擎使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。

类似于多处理器计算机的内存模型，Java内存模型规定了所有的变量（包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为它们是线程私有的，不会被共享，自然不存在竞争问题）都存储在主内存中。每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法去等并不是同一个层次的内存划分，这两者基本上是没有关系，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上来说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器或者高速缓存中，因为程序运行时主要访问读写的是工作内存。

### 3.内存间交互操作

关于主内存与工作内存之间具体的交互协议，Java内存模型中定义了8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外，即long与double的非原子协定）。

需要注意的一点是，在JSR-133文档中，已经放弃了采用这8种操作去定义Java内存模型的访问协议了（仅是描述方式改变了，Java内存模型并没有改变）。

- lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定。
- read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令操作时执行这个操作。
- store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
- write（写入）：作用于主内存的变量，它把store操作从工作内存中取到的变量的值放入主内存的变量中。

如果要把一个变量从主内存复制到工作内存，那就要顺序的执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证连续执行。

Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：

- 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起了回写但主内存不接受的情况出现。
- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。
- 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
- 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。

这8种内存访问操作以及上述规则限定，再加上对volatile的一些特殊规定，就已经完全确定了Java程序中哪些操作在并发下是安全的。但这种定义相当严谨但又十分繁琐，实践起来很麻烦，还有一种等效判断原则——现行发生原则，用来确定一个访问在并发环境下是否安全。

### 4.long与double型的非原子性协定

Java内存要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性（在32位操作系统上对64位的数据的读写要分两步完成，每一步取32位数据），这点就是所谓的long和double的非原子性协定。

如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并同时对它们进行读取和修改操作，那么某个线程可能会读取到一个既非原值，也不是其它线程修改值的代表了“半个变量”的数值。

不过这种读取到“半个变量”的情况非常罕见（在目前商用Java虚拟机中不会出现），因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。

### 5.先行发生原则

先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据。它是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A现行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等（这里要注意的一点是操作A在时间上比操作B早发生，先行发生描述的并不是一种时间上的先后关系）。

Java内存模型中存在一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法通过这些规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。

- **程序次序规则：**在一个线程内，按照程序代码顺序，书写在前面的操作先行发生与书写在后面的操作。准确的说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构（**注意，这里的先行发生并不是指时间上的先后顺序**）。
- **管程锁定规则：**一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
- **volatile变量规则：**对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
- **线程启动规则：**Thread对象的start()方法先行发生于此线程的每一个动作。
- **线程终止规则：**线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测线程已经终止了。
- **线程中断规则：**对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
- **对象终结规则：**一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
- **传递性：**如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

接下来我们通过一个例子展示“时间上的先发生”并不代表这个操作会“先行发生”：

```java
private int value = 0;

public void setValue(int value) {
    this.value = value;
}

public int getValue() {
    return value;
}
```

对于上述代码，我们假设存在线程A和线程B，线程A先（时间上的先后）调用了`setValue(1)`，然后线程B调用了同一个对象的`getValue()`，那么线程B收到的返回值是什么？

我们依次分析一下先行发生原则中的各项规则，由于两个方法分别由线程A和线程B调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然也不会发生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断和对象终结规则也和这里完全没有关系，因为没有一个使用的先行发生规则，所以最后一条传递性也无从谈起。因此我们可以判定尽管线程A在操作时间上先于线程B，但是无法确定线程B中的`getValue()`方法的返回结果，换句话说，这里的操作不是线程安全的。

那么如果一个操作“先行发生”能否推导出这个操作必定是“时间上先发生”呢？这个推论是不成立的，一个典型的例子就是“指令重排序”：

```java
// 以下操作在同一个线程中执行
int i = 1;
int j = 2;
```

这两条赋值语句在同一个线程之中，根据程序次序规则，`int i = 1`的操作先行发生于`int j = 2`，但是`int j = 2`的代码完全可能先被处理器执行，这并不影响先行发生原则的准确性，因为我们在这条线程中没有办法感知到这点（指令重排序并不会导致结果发生变化，因此在单线程中会表现为程序串行执行）。

因此，**时间先后顺序与先行发生原则之间基本没有太大关系**，所以我们衡量并发安全问题的时候不要收到时间顺序的干扰，一切必须以先行发生原则为准。

### 6.Java与线程

并发不一定要依赖多线程（如PHP中很常见的多进程并发），但是在Java里面谈论并发，大多数都与线程脱不开关系。

#### 6.1.线程的实现

线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。

主流的操作系统都提供了线程实现，Java语言则提供了在不同的硬件和操作系统平台下对线程操作的统一处理，每个已经执行了`start()`且还未结束的`java.util.Thread`类的实例就代表了一个线程。`Thread`类中的所有关键方法都声明为Native的（在Java API中，一个Native方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现）。

实现线程的主要方式有3种：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。

##### 6.1.1使用内核线程实现

内核线程（KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过线程调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。

程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。

由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。其次，每个轻量级进程都需要一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

##### 6.1.2使用用户线程实现

从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程。而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态完成，不需要内核帮助。如果程序实现得当，这种线程不需要切换内核态，因此操作可以是非常快速且低消耗的，也可以支持更大规模的线程数量。这种进程与用户线程之间1:N的关系称为一对多的线程模型。

它的劣势在于所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至不可能完成。

##### 6.1.3使用用户线程加轻量级进程混合实现

在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进程呗完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N:M的关系，这种就是多对多的线程模型。

##### 6.1.4Java线程的实现

在JDK1.2之前，是基于称为“绿色线程”的用户线程实现的，而在JDK1.2中，线程模型替换为基于操作系统原生线程模型来实现。线程模型只是对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异是透明的。

对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows与Linux系统提供的线程模型就是一对一的。

#### 6.2.Java线程调度

线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。

如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另一个线程上。这种方式没有什么线程同步的问题，但是线程执行时间不可控制。

如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，**Java使用的线程调度方式就是抢占式调度**。

虽然Java线程调度是系统自动完成的，但是我们可以“建议”系统给某些线程多分配一些执行时间，另外的一些线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。Java语言中一共设置了10个优先级，但是需要注意的是线程调度最终还是取决于操作系统，虽然现在很多操作系统中都由线程优先级的概念，但并不见得能与Java线程的优先级一一对应。

**我们不能在程序中通过优先级来完全准确的判断出都为Ready的线程将会先执行哪一个**。

#### 6.3.状态转换

Java语言定义了5种线程状态，在任意一个时间点，一个线程有且只能有其中一种状态：

- 新建（New）：创建后尚未启动的线程处于这种状态。
- 运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间。
- 无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式的唤醒。以下方法会让线程陷入无限期的等待状态：
  - 没有设置Timeout参数的Object.wait()方法。
  - 没有设置Timeout参数的Thread.join()方法。
  - LockSupport.park()方法。
- 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式的唤醒，在一定时间之后他们会由系统自动唤醒。以下方法会让线程进入限期等待状态：、
  - Tread.sleep()方法。
  - 设置了Timeout参数的Object.wait()方法。
  - 设置了Timeout参数的Thread.join()方法。
  - LockSupport.parkNanos()方法。
  - LockSupport.parkUntil()方法。
- 阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排它锁，这个事件将在另一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。