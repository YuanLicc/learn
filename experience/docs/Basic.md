# 基础概念

## 1. 面向对象

### 1.1 概念



### 1.2 问题

#### 1.2.1 面向对象软件开发优点 ？

回答1：

- 代码开发模块化，更易维护和修改。
- 代码复用。
- 增强代码的可靠性和灵活性。
- 增加代码的可理解性。



#### 1.2.2 抽象类和接口的区别，类可以继承多个类吗？接口可以继承多个接口吗？类可以实现多个接口吗？

- 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 
- 抽象类要被子类继承，接口要被类实现。　　
- 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 
- 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 
- 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 
- 抽象方法只能申明，不能实现。 
- 抽象类里可以没有抽象方法 。
- 如果一个类里有抽象方法，那么这个类只能是抽象类 。
- 抽象方法要被实现，所以不能是静态的，也不能是私有的。 
- 接口可继承接口，并可多继承接口，但类只能单根继承。



#### 1.2.3 继承和聚合的区别在哪？

​	继承指的是一个类（称为子类、子类接口）继承另外一个类（称为父类、父接口）的功能，并可以增加它自己的新功能，继承是类与类或者接口之间最常见的关系。在 `Java` 中此类关系通过关键字 `extends` 明确标识。 



#### 1.2.4 什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？  

​	不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。 



#### 1.2.5 我们能创建一个包含可变对象的不可变对象吗？ 

​	是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。



#### 1.2.6 Java 中应该使用什么数据类型来代表价格？ 

​	如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。 



#### 1.2.7 存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B？

 可以，向下转型。但是不建议使用，容易出现类型转型异常. 



#### 1.2.8 JRE、JDK、JVM 及 JIT 之间有什么不同？

​	JRE 代表 Java 运行时（Java run-time），是运行 Java 应用所必须的。

​	JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。

​	JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。 

附（关系图）：

![JDKãJREãJVMä¸èçåºå«ä¸èç³» - ä»¥å¾·ç³äºº - ââæ¨è¸¢æ°å·¥ Playkidââ](http://img1.ph.126.net/A2iWlmXbFe6tSz2rRGkz-A==/727331339920439686.jpg)  

#### 1.2.9 final、finalize 和 finally 的不同之处？

​	final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。 



#### 1.2.10 Java 中的编译期常量是什么？使用它又什么风险？

​	公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。 



#### 1.2.11 说出几条 Java 中方法重载的最佳实践？

a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。  

b）如果重载的方法参数个数多于 5 个，采用可变参数。 



#### 1.2.12 接口是什么？为什么要使用接口而不是直接使用具体类？

​	接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。



#### 1.2.13 Java 中，抽象类与接口之间有什么不同？

​	Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。 



#### 1.2.14 抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？

​	一个类可以实现多个接口，但只能继承一个抽象类；抽象类可以包含具体的方法，接口所有的方法都是抽象的（JDK8开始新增功能接口中有default方法）；抽象类可以声明和使用字段，接口则不能，但可以创建静态的final常量；抽象类的方法可以是protected、public、private或者默认的package，接口的方法都是public；抽象类可以定义构造函数，接口不能；接口被声明为public，省略后，包外的类不能访问接口。



#### 1.2.15 继承和组合之间有什么不同？

​	虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。



#### 1.2.16 描述 Java 中的重载和重写？

​	重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。  



#### 1.2.17 Java 中，嵌套公共静态类与顶级类有什么不同？

​	类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。



#### 1.2.18 OOP 中的 组合、聚合和关联有什么区别？

​	如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。 



#### 1.2.19 嵌套静态类与顶级类有什么区别？

​	一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。 



#### 1.2.20 Java 中，受检查异常 和 不受检查异常的区别？

​	受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。其中一种情况是 Exception 的子类但不是 RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶段不受编译器的检查。 



#### 1.2.21 Java 中，throw 和 throws 有什么区别？

​	throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如： throw new IllegalArgumentException(“size must be multiple of 2″) 而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。



#### 1.2.22 Object中的方法

- hashCode()：用户获取对象的hash值，用于检索。

- queals()：用于确认两个对象是否相等；补充，哈希值相同的对象不一定equals()，但equals()的两个对象，hash值一定相等。

- toString()：返回一个String对象，用来标识自己。

- getClass()：返回一个class对象，打印的格式一般为  class package.name.xxx，经常用于java的反射机制。

- clone()：用来另存一个当前存在的对象。

- finalize()：垃圾回收的时候用到，匿名对象回收之前会调用到。

- wait()：用于让当前线程失去操作权限，当前线程进入等待序列。

- wait(long)、wait(long,int)：用户设定下一次获取锁的距离当前释放锁的间隔时间。

- notify()：用于随机通知一个持有对象锁的线程获取操作的权限。

- notifyAll()：用于通知所有持有对象锁的线程获取操作权限。



#### 1.2.23 传值和传引用的区别，java是怎么样的，有没有传值传引用？

​	首先，java中是没有指针的，只存在值传递；而我们经常看到对于对象的传递似乎有点像引用传递，可以改变对象中的某个属性的值，请不要被这个假象蒙蔽了双眼，实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以还是按值传递。

​	传值调用时，改变的是形参的值，并没有改变实参的值，实参的值可以传递给形参，但是这个传递是单向的，形参不能传递会实参。

​	传引用调用时，如果参数是对象，无论是对象做了何种操作，都不会改变实参对象的引用，但是如果改变了对象的内容，就会改变实参对象的内容。



#### 几个关键字的作用域？

|          | public | protected | default | private |
| -------- | ------ | --------- | ------- | ------- |
| 同一个类 | OK     | OK        | OK      | OK      |
| 同一个包 | OK     | OK        | OK      | NO      |
| 子父类   | OK     | OK        | NO      | NO      |
| 不同包   | OK     | NO        | NO      | NO      |



#### Java 关键字、保留字、特殊直接量？

1）48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。

2）2个保留字（现在没用以后可能用到作为关键字）：goto、const。

3）3个特殊直接量：true、false、null。



#### 类初始化过程？

​	父类的静态变量-父类的静态代码块 子类的静态变量-子类的静态代码块 父类的非静态变量-父类的非静态代码块-父类的构造函数 子类的非静态变量-子类的非静态代码块-子类的构造函数。规律就是：父类先于子类，静态的先于非静态的，变量先于代码块。



#### 接口修饰关键字有哪些？

- 访问修饰符

  `public` 、默认值。

- 其它

  `abstract（冗余的，因为接口本来就是抽象的）`



#### 接口方法关键字有哪些？

- 访问修饰符

  默认值：`public`，

- 其它

  默认值：`abstract`，`static(Java 8)`，`default(Java 8)`



## 概念

### 内部类

#### 为什么使用内部类?

​	使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现， 对于内部类都没有影响。

​	使用内部类最大的优点：在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性: 

(1) 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独。 

(2) 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。 

(3) 创建内部类对象的时刻并不依赖于外围类对象的创建。

(4) 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。 

(5) 内部类提供了更好的封装，除了该外围类，其他类都不能访问。 

#### 成员内部类

1、内部类定义在外围类的内部，相当于外围类的一个成员变量的位置，内部类可以使用任意访问控制符， 如 `public`、`protected`、`private` 等。

2、内部类中定义的方法可以直接访问外围类中的数据，而不受访问控制符的影响。

3、定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 `new` 一个内部类对象， 即：`内部类 对象名 = 外部类对象.new 内部类( )`。

4、编译产生了两个 `.class` 文件: `Outer.class, Outer$Inner.class{}`。

5、成员内部类中不能存在任何 `static` 的变量和方法，可以定义常量：

(1) 因为非静态内部类是要依赖于外部类的实例，而静态变量和方法是不依赖于对象的，仅与类相关，简而言之：在加载静态域时,根本没有外部类，所在在非静态内部类中不能定义静态域或方法，编译不通过。非静态内部类的作用域是实例级别。

(2) 常量是在编译器就确定的，放到所谓的常量池了 。

#### 静态内部类

1、静态内部类不能直接访问外部类的非静态成员，但可以通过 `new 外部类().成员` 的方式访问。

2、如果外部类的静态成员与内部类的成员名称相同，可通过 `类名.静态成员` 访问外部类的静态成员； 如果外部类的静态成员与内部类的成员名称不相同，则可通过 `成员名` 直接调用外部类的静态成员。

3、创建静态内部类的对象时，不需要外部类的对象，可以直接创建 `内部类 对象名 = new 内部类()`。

#### 方法内部类

1、局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。

2、只能访问方法中定义的 final 类型的局部变量，因为: 当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在，直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量; ==>使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期. 局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部， 自己内部的方法调用的实际是自己的属性而不是外部类方法的参数;。防止被篡改数据，而导致内部类得到的值不一致。

#### 匿名内部类

1、匿名内部类是直接使用 new 来生成一个对象的引用。

2、对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。

3、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。

4、匿名内部类中是不能定义构造函数的,匿名内部类中不能存在任何的静态成员变量和静态方法。

5、匿名内部类中不能存在任何的静态成员变量和静态方法,匿名内部类不能是抽象的,它必须要实现继承的类或者实现的接口的所有抽象方法。

6、匿名内部类初始化：使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。



### Comparable以及Comparator总结

#### 相同点

​	无论是Comparable接口还是Comparator接口都是为了实现对象的可比较性，之后通过对象间的比较进而通过Collection.sort()或者Arrays.sort()方法对集合或对象数组进行排序。

#### 区别

1.实现方法 
 Comparable接口需要实现int compareTo(T t)方法。 
 Comparator接口实现的是int compare(Object o1,Object o2)方法。

2.存放位置 
 Comparable接口存放于java.lang中。 
 Comparator接口存放于java.util中。

3.使用方式（见代码实例） 
 Comparable接口是实现于实体类中，如果需要修改比较方式则需要修改实体类的源代码。 
 Comparator接口独立实现于外部，通过传入比较器实例从而实现对象的排序。

#### finalize()——析构函数的替代者

​	首先提一下析构函数，析构函数与构造函数相反，当对象在的函数已经调用完毕的时候，系统会自动的执行析构函数（析构函数存在于C++等语言中）。

​	java提供[**finalize**](http://www.51testing.com/javascr%C4%ABpt:;)()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。 

​	Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 

####线程状态转换图

![img](https://uploadfiles.nowcoder.com/images/20180701/3807435_1530424646801_3658A873352D1D5FB9EF74D9F9F1F0B5) 

#### 关于servlet

init方法： 是在servlet实例创建时调用的方法，用于创建或打开任何与servlet相的资源和初始 化servlet的状态，Servlet规范保证调用init方法前不会处理任何请求 

 service方法：是servlet真正处理客户端传过来的请求的方法，由web容器调用， 根据HTTP请求方法（GET、POST等），将请求分发到doGet、doPost等方法 

destory方法：是在servlet实例被销毁时由web容器调用。Servlet规范确保在destroy方法调用之 前所有请求的处理均完成，需要覆盖destroy方法的情况：释放任何在init方法中 打开的与servlet相关的资源存储servlet的状态

