## Synchronized 相关

### 1. synchronized关键字的用法，优缺点？

java关键字，当它用来修饰一个方法或者代码块的时候，能够保证在同一时刻最多只有一个线程执行该代码段的代码。

synchronized修饰的方法或者对象，只能以同步的方式执行，会引起性能问题；无法中断一个正在等候获得锁的线程，也无法通过投票获得锁；一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。



## 线程安全与锁优化

### 1线程安全

对于线程安全，引用《Java Concurrency In Pratice》的作者Brian Goetz的描述是：”当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的“。

上述定义比较严谨，它要求线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。在大多数场景中，我们都会将这个定义弱化一些，如果把“调用这个对象的行为”限定为“单次调用”，这个定义的其他描述也能够成立的话，我们就可以称它是线程安全了。

#### 1.1Java语言中的线程安全

我们这里讨论的线程安全，就限定于多个线程之间存在共享数据访问这个前提，因为如果一段代码根本不会与其它线程共享数据，那么从线程安全的角度上来看，程序是串行执行还是多线程执行对它来说是完全没有区别的。

我们可以不把线程安全当做一个非真既假的二元排他项来看待，按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

##### 不可变：

在Java语言中（特指JDK1.5以后，即Java内存模型被修正之后的Java语言），不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的任何的线程安全保障措施。只要一个不可变的对象被正确的构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远不会改变，永远也不会看到它在多个线程之中处于不一致的状态，“不可变”带来的安全性是最简单和最纯粹的。

Java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。

##### 绝对线程安全：

绝对的线程安全完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。

java.util.Vector是一个线程安全的容器，因为它的`add()`、`get()`和`size()`这类方法都是被synchronized修饰的。但是，即使它所有的方法都被修饰为同步，也不意味着调用它的时候永远都不需要同步手段了。

```java
private static Vector<Integer> vector = new Vector<>();

public static void main(String[] args) {
    while (true) {
        for (int i = 9; i < 10; i++) {
            vector.add(i);
        }
        
        Thread removeThread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < vector.size(); i++) {
                    vector.remove(i);
                }
            }
        });
        
        Thread printThread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < vector.size(); i++) {
                    System.out.println(vector.get(i));
                }
            }
        });
        
        removeThread.start();
        printThread.start();
        
        // 不要同时产生过多的线程，否则会导致操作系统假死
        while (Thread.activeCount() > 20);
    }
}
```

很明显，尽管这里使用到的Vector的`get()`、`remove()`和`size()`方法都是同步的，但是在多线程环境中，如果不在方法调用端做额外的同步措施的话，使用这段代码仍然是不安全的。因为如果一个线程恰好在错误的时间里删除了一个i，导致序号i已经不再可用的话，再用i访问数组就会抛出一个`ArrayIndexOutOfBoundsException`。如果想要上述代码能够正常运行下去，需要进行如下修改：

```java
Thread removeThread = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (vector) {
                    for (int i = 0; i < vector.size(); i++) {
                    	vector.remove(i);
                	}
                }
            }
        });
        
        Thread printThread = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (vector) {
                    for (int i = 0; i < vector.size(); i++) {
                    	System.out.println(vector.get(i));
                	}
                }
            }
        });
```

##### 相对线程安全：

相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性（这就是我们前面所说的，将这个定义弱化一些，把“调用这个对象的行为”限定为“单次调用”）。

在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。

##### 线程兼容：

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境下可以安全的使用，我们平常说一个线程不是线程安全的，绝大多数时候是指这一种情况。Java API中大部分类都是属于线程兼容的，如前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。

##### 线程对立：

线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。常见的线程对立的例子有Thread类的suspend()和resume()方法（已经被JDK声明废弃了）、System.setIn()、System.setOut和System.runFinalizersOnExit()等。

#### 1.2线程安全的实现方法

##### 互斥同步

互斥同步是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、信号量、互斥量都是主要的互斥实现方式。

在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或者Class对象来作为锁对象。

根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。

使用sychronized关键字需要注意，首先，synchronized同步块对于同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完毕之前，会阻塞后面其它线程的进入。Java的线程是映射到操作系统的原生线程上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多处理器时间，对于代码简单的同步块，状态转换消耗的时间有可能比用户代码执行的时间还要长。所以，**synchronized是Java语言中一个重量级的操作**。

除了synchronized之外，我们还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步，它们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁（lock()和unlock()方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。相比于synchronized，ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。

- 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
- 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
- 锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或nofityAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外的添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。

JDK1.5多线程环境中synchronized的吞吐量下降的非常严重，而ReentrantLock则能基本保持在同一个比较稳定的水平上。JDK1.6中synchronized与ReentractLock的性能基本持平了，如果实在JDK1.6或以上部署项目的话，性能因素就不再是选择ReentractLock的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的synchronized，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。

##### 非阻塞同步

互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的的性能问题，因此这种同步方式也称为阻塞同步，从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题。

随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗的所，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。

为什么说乐观并发策略需要硬件指令集的发展才能进行呢？因为我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次的操作只通过一条处理器指令就能完成，这类指令常用的有：

- 测试并设置（Test-and-Set）。
- 获取并增加（Fetch-and-Increment）。
- 交换（Swap）。
- 比较并交换（Compare-and-Swap，CAS）。
- 加载链接/条件存储（Load-Linked/Store-Conditional，LL/SC）.

CAS指令需要3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用B更新V值，否则它就不执行更新，但无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。

在JDK1.5之后，Java程序中才可以使用CAS操作，该操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供，虚拟机内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用过程，或者可以认为无条件内联进去了（这种被虚拟机特殊处理的方法称为固有函数，类似的固有函数还有Math.sin()等）。

由于Unsafe类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器加载的Class才能访问它），因此，如果不采用反射手段，我们只能通过其他Java API来间接使用它，如java.util.concurrent包里面的整数原子类，其中的compareAndSet()和getAndIncrement()等方法都是用了Unsafe类的CAS操作。

虽然CAS操作看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，存在这样一个逻辑漏洞：如果变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？ 

##### 无同步方案

要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，下面举两个例子。

- 可重入代码

  这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入代码都是线程安全的。我们可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也是线程安全的。

- 线程本地存储

  Java中可以通过java.lang.ThreadLocal类实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。

### 2锁优化

高效并发是从JDK1.5到JDK1.6的一个重要改进，引入了许多的锁优化技术，这些技术都是为了在线程之间更高效的共享数据，以解决竞争问题，从而提高程序的执行效率。

#### 2.1自旋锁与自适应自旋

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。另外，在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这短时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自旋锁在JDK1.4.2中就已经引入，不过是默认关闭的，在JDK1.6中就已经改为默认开启了。自旋等待不能代替阻塞，且不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋默认的次数为10次，可以通过参数-XX:PreBlockSpin来更改。

在JDK1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能会再次成功，进而它将允许自旋等待持续相对更长的时间，例如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。

#### 2.2锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然也就无需进行。

在Java程序中，同步代码的普遍程度可能超出了我们的想象，例子如下：

```java
public String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
```

由于String是一个不可变类，对于字符串的连接操作总是通过生成新的String对象来进行的，因此**Javac**编译器会对String连接做自动优化。在JDK1.5之前，会转化为StringBuffer对象的连续append()操作，在JDK1.5及以后的版本中，会转化为StringBuilder对象的连续append()操作，即上述代码可能会变成下面的样子：

```java
public String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```

因次，一段看起来没有同步代码块的代码便出现了同步。虚拟机观察变量sb，很快就会发现它的动态作用域被限制在了concatString()方法内部。也就是说，sb的所有引用永远不会“逃逸”到concatString()方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全的消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。

#### 2.3锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用域范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁竞争的线程也能尽快拿到锁。但是如果一些列的连续操作都是对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那么即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

#### 2.4轻量级锁

轻量级锁是JDK1.6之中加入的新型锁机制，它名字中的轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就成为重量级锁。需要强调的一点是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的消耗。

要理解轻量级锁，必须从HotSpot虚拟机的对象（对象头部分）的内存布局开始。HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”，它是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针（类型指针），如果是数组对象的话，还会有一个额外的部分用于存储数组长度。

在代码进入同步块的时候，如果此对象没有被锁定（锁标识位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。

然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为00，即表示此对象处于轻量级锁定状态。

如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级就不再有效，要膨胀为重量级锁，锁标志的状态值变为10，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

它的解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向这线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。

轻量级锁能够提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

#### 2.5偏向锁

偏向锁是JDK1.6中引入的一项优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去清除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不作了。

偏向锁的“偏”，就是偏心的“偏”，偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

假设当前虚拟机开启了偏向锁（-XX:+UseBiasedLocking，这个是JDK1.6的默认值），那么，当锁对象第一次被线程获取的时候，虚拟机会把对象头中的标志位设置为01，即偏向模型。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如Locking、Unlocking及对Mark Word的Update等）。

当有另一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后续的同步操作就如轻量级锁那样执行。

偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多于的。在具体问题具体分析的前提下，有时候使用-XX:UseBiaselLocking来禁止偏向锁优化反而可以提升性能。

